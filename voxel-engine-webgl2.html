<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Ray Traversal Engine v2 - WebGL2</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; cursor: crosshair; }
        #canvas-container.locked { cursor: none; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui { width: 280px; background: #16213e; padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2em; margin-bottom: 5px; color: #e94560; }
        .version { font-size: 0.75em; color: #4ecca3; margin-bottom: 15px; }
        h2 { font-size: 0.95em; margin: 15px 0 10px; color: #0f3460; background: #e94560; padding: 5px 10px; border-radius: 4px; }
        .stat { display: flex; justify-content: space-between; margin: 8px 0; font-size: 0.85em; }
        .stat-label { color: #888; }
        .stat-value { color: #4ecca3; font-family: monospace; }
        .stat-value.highlight { color: #ffd700; }
        .control-group { margin: 10px 0; }
        label { display: block; margin-bottom: 5px; font-size: 0.85em; color: #888; }
        input[type="range"] { width: 100%; margin: 5px 0; }
        select { width: 100%; padding: 8px; background: #0f3460; border: none; color: #eee; border-radius: 4px; }
        .info { background: #0f3460; padding: 10px; border-radius: 4px; font-size: 0.8em; line-height: 1.5; margin-top: 15px; }
        .key { background: #e94560; padding: 2px 6px; border-radius: 3px; font-family: monospace; margin: 1px; }
        #overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: none; opacity: 1; transition: opacity 0.3s; }
        #overlay.hidden { opacity: 0; }
        #overlay h2 { background: none; color: #fff; font-size: 1.5em; }
        #overlay p { color: #aaa; margin-top: 10px; }
        .crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; opacity: 0; transition: opacity 0.3s; }
        .crosshair.visible { opacity: 0.7; }
        .crosshair::before, .crosshair::after { content: ''; position: absolute; background: #fff; }
        .crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
        .crosshair::after { width: 100%; height: 2px; top: 50%; transform: translateY(-50%); }
        .badge { display: inline-block; background: #4ecca3; color: #0f3460; padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: bold; margin-left: 5px; }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="overlay"><h2>Click to Start</h2><p>Use WASD to move, mouse to look</p></div>
            <div class="crosshair"></div>
        </div>
        <div id="ui">
            <h1>üéÆ Voxel Ray Traversal</h1>
            <div class="version">v2.0 - WebGL2 GPU Accelerated <span class="badge">NEW</span></div>
            
            <h2>üìä Statistics</h2>
            <div class="stat"><span class="stat-label">FPS</span><span class="stat-value highlight" id="fps">0</span></div>
            <div class="stat"><span class="stat-label">Frame Time</span><span class="stat-value" id="frame-time">0 ms</span></div>
            <div class="stat"><span class="stat-label">Resolution</span><span class="stat-value" id="resolution-display">0 x 0</span></div>
            <div class="stat"><span class="stat-label">Voxels</span><span class="stat-value" id="voxel-count">0</span></div>
            
            <h2>üì∑ Camera</h2>
            <div class="stat"><span class="stat-label">Position</span><span class="stat-value" id="cam-pos">(0, 0, 0)</span></div>
            <div class="stat"><span class="stat-label">Direction</span><span class="stat-value" id="cam-dir">(0, 0, 0)</span></div>
            
            <h2>‚öôÔ∏è Settings</h2>
            <div class="control-group">
                <label>Resolution Scale</label>
                <input type="range" id="resolution" min="0.25" max="2" step="0.25" value="1">
                <span class="stat-value" id="resolution-val">1x</span>
            </div>
            <div class="control-group">
                <label>World Size</label>
                <select id="world-size">
                    <option value="32">32¬≥ (32K voxels)</option>
                    <option value="64" selected>64¬≥ (262K voxels)</option>
                    <option value="128">128¬≥ (2M voxels)</option>
                    <option value="256">256¬≥ (16M voxels)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Max Steps</label>
                <input type="range" id="max-steps" min="64" max="512" step="64" value="256">
                <span class="stat-value" id="max-steps-val">256</span>
            </div>
            <div class="control-group">
                <label>FOV</label>
                <input type="range" id="fov" min="30" max="120" step="5" value="70">
                <span class="stat-value" id="fov-val">70¬∞</span>
            </div>
            <div class="control-group">
                <label>Scene</label>
                <select id="scene">
                    <option value="demo">Demo Scene</option>
                    <option value="sphere">Sphere</option>
                    <option value="terrain">Terrain</option>
                    <option value="city">City</option>
                </select>
            </div>
            <div class="control-group">
                <label><input type="checkbox" id="show-normals"> Show Normals</label>
            </div>
            <div class="control-group">
                <label><input type="checkbox" id="enable-shadows" checked> Enable Shadows</label>
            </div>
            
            <div class="info">
                <strong>Controls:</strong><br>
                <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Move<br>
                <span class="key">Q</span><span class="key">E</span> - Up/Down<br>
                <span class="key">Mouse</span> - Look<br>
                <span class="key">Scroll</span> - Zoom<br>
                <span class="key">ESC</span> - Release cursor
            </div>
        </div>
    </div>

<!-- Vertex Shader -->
<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec2 a_position;
out vec2 v_uv;

void main() {
    v_uv = a_position * 0.5 + 0.5;
    gl_Position = vec4(a_position, 0.0, 1.0);
}
</script>

<!-- Fragment Shader - DDA Ray Traversal -->
<script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision highp float;
precision highp sampler3D;

in vec2 v_uv;
out vec4 fragColor;

uniform sampler3D u_voxelData;
uniform vec3 u_cameraPos;
uniform vec3 u_cameraDir;
uniform vec3 u_cameraUp;
uniform vec3 u_cameraRight;
uniform vec2 u_resolution;
uniform float u_fov;
uniform float u_worldSize;
uniform int u_maxSteps;
uniform int u_showNormals;
uniform int u_enableShadows;
uniform vec3 u_lightDir;

// Sky colors
const vec3 SKY_TOP = vec3(0.1, 0.1, 0.44);
const vec3 SKY_BOTTOM = vec3(0.53, 0.81, 0.92);

// Ray-box intersection
vec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - rayOrigin) / rayDir;
    vec3 tMax = (boxMax - rayOrigin) / rayDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

// Get voxel at position
vec4 getVoxel(ivec3 pos) {
    if (pos.x < 0 || pos.y < 0 || pos.z < 0 ||
        pos.x >= int(u_worldSize) || pos.y >= int(u_worldSize) || pos.z >= int(u_worldSize)) {
        return vec4(0.0);
    }
    return texelFetch(u_voxelData, pos, 0);
}

// DDA Ray Traversal
struct HitResult {
    bool hit;
    vec3 pos;
    vec3 normal;
    vec4 color;
    float distance;
    int steps;
};

HitResult traceRay(vec3 origin, vec3 direction) {
    HitResult result;
    result.hit = false;
    result.steps = 0;
    result.normal = vec3(0.0);
    
    // Intersect with world bounds
    vec2 tBox = intersectAABB(origin, direction, vec3(0.0), vec3(u_worldSize));
    if (tBox.x > tBox.y || tBox.y < 0.0) {
        return result;
    }
    
    float tStart = max(0.0, tBox.x) + 0.001;
    vec3 startPos = origin + direction * tStart;
    
    // Current voxel coordinates
    ivec3 mapPos = ivec3(floor(startPos));
    mapPos = clamp(mapPos, ivec3(0), ivec3(int(u_worldSize) - 1));
    
    // Step direction
    ivec3 step = ivec3(sign(direction));
    
    // Delta - how far along ray to move for 1 unit in each axis
    vec3 deltaDist = abs(vec3(1.0) / direction);
    
    // Distance to next voxel boundary
    vec3 sideDist = (sign(direction) * (vec3(mapPos) - startPos) + (sign(direction) * 0.5) + 0.5) * deltaDist;
    
    // Track which axis we crossed
    int side = 0;
    
    // DDA loop
    for (int i = 0; i < 512; i++) {
        if (i >= u_maxSteps) break;
        result.steps = i + 1;
        
        // Check current voxel
        vec4 voxel = getVoxel(mapPos);
        if (voxel.a > 0.0) {
            result.hit = true;
            result.color = voxel;
            result.pos = vec3(mapPos);
            
            // Set normal based on side hit
            result.normal = vec3(0.0);
            if (side == 0) result.normal.x = -float(step.x);
            else if (side == 1) result.normal.y = -float(step.y);
            else result.normal.z = -float(step.z);
            
            // Calculate distance
            if (side == 0) result.distance = (float(mapPos.x) - origin.x + (1.0 - float(step.x)) / 2.0) / direction.x;
            else if (side == 1) result.distance = (float(mapPos.y) - origin.y + (1.0 - float(step.y)) / 2.0) / direction.y;
            else result.distance = (float(mapPos.z) - origin.z + (1.0 - float(step.z)) / 2.0) / direction.z;
            
            return result;
        }
        
        // DDA step - move to next voxel
        if (sideDist.x < sideDist.y) {
            if (sideDist.x < sideDist.z) {
                sideDist.x += deltaDist.x;
                mapPos.x += step.x;
                side = 0;
            } else {
                sideDist.z += deltaDist.z;
                mapPos.z += step.z;
                side = 2;
            }
        } else {
            if (sideDist.y < sideDist.z) {
                sideDist.y += deltaDist.y;
                mapPos.y += step.y;
                side = 1;
            } else {
                sideDist.z += deltaDist.z;
                mapPos.z += step.z;
                side = 2;
            }
        }
        
        // Check bounds
        if (mapPos.x < 0 || mapPos.x >= int(u_worldSize) ||
            mapPos.y < 0 || mapPos.y >= int(u_worldSize) ||
            mapPos.z < 0 || mapPos.z >= int(u_worldSize)) {
            break;
        }
    }
    
    return result;
}

// Simple shadow check
float traceShadow(vec3 origin, vec3 direction) {
    vec3 startPos = origin + direction * 0.01;
    
    ivec3 mapPos = ivec3(floor(startPos));
    ivec3 step = ivec3(sign(direction));
    vec3 deltaDist = abs(vec3(1.0) / direction);
    vec3 sideDist = (sign(direction) * (vec3(mapPos) - startPos) + (sign(direction) * 0.5) + 0.5) * deltaDist;
    
    for (int i = 0; i < 128; i++) {
        if (mapPos.x < 0 || mapPos.x >= int(u_worldSize) ||
            mapPos.y < 0 || mapPos.y >= int(u_worldSize) ||
            mapPos.z < 0 || mapPos.z >= int(u_worldSize)) {
            return 1.0;
        }
        
        vec4 voxel = getVoxel(mapPos);
        if (voxel.a > 0.0) {
            return 0.3;
        }
        
        if (sideDist.x < sideDist.y) {
            if (sideDist.x < sideDist.z) {
                sideDist.x += deltaDist.x;
                mapPos.x += step.x;
            } else {
                sideDist.z += deltaDist.z;
                mapPos.z += step.z;
            }
        } else {
            if (sideDist.y < sideDist.z) {
                sideDist.y += deltaDist.y;
                mapPos.y += step.y;
            } else {
                sideDist.z += deltaDist.z;
                mapPos.z += step.z;
            }
        }
    }
    
    return 1.0;
}

void main() {
    // Calculate ray direction for this pixel
    float aspectRatio = u_resolution.x / u_resolution.y;
    float fovRad = u_fov * 3.14159265 / 180.0;
    float halfHeight = tan(fovRad / 2.0);
    float halfWidth = aspectRatio * halfHeight;
    
    vec2 ndc = v_uv * 2.0 - 1.0;
    vec3 rayDir = normalize(u_cameraDir + u_cameraRight * ndc.x * halfWidth + u_cameraUp * ndc.y * halfHeight);
    
    // Trace primary ray
    HitResult hit = traceRay(u_cameraPos, rayDir);
    
    vec3 color;
    
    if (hit.hit) {
        if (u_showNormals == 1) {
            // Visualize normals
            color = hit.normal * 0.5 + 0.5;
        } else {
            // Basic shading
            vec3 baseColor = hit.color.rgb;
            
            // Diffuse lighting
            float diffuse = max(0.3, dot(hit.normal, u_lightDir));
            
            // Shadow
            float shadow = 1.0;
            if (u_enableShadows == 1) {
                vec3 shadowOrigin = hit.pos + hit.normal * 0.5 + vec3(0.5);
                shadow = traceShadow(shadowOrigin, u_lightDir);
            }
            
            // Distance fog
            float fog = clamp(hit.distance / (u_worldSize * 1.5), 0.0, 1.0);
            vec3 fogColor = mix(SKY_TOP, SKY_BOTTOM, 0.5);
            
            color = baseColor * diffuse * shadow;
            color = mix(color, fogColor, fog * 0.8);
        }
    } else {
        // Sky gradient
        color = mix(SKY_TOP, SKY_BOTTOM, v_uv.y);
    }
    
    fragColor = vec4(color, 1.0);
}
</script>

<script>
// ============================================================================
// WebGL2 Voxel Engine
// ============================================================================

class VoxelEngineWebGL2 {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl2');
        
        if (!this.gl) {
            alert('WebGL2 not supported!');
            return;
        }
        
        this.resolutionScale = 1.0;
        this.worldSize = 64;
        this.maxSteps = 256;
        this.fov = 70;
        this.showNormals = false;
        this.enableShadows = true;
        
        // Camera
        this.cameraPos = [32, 40, -20];
        this.cameraYaw = 0;
        this.cameraPitch = -0.3;
        this.moveSpeed = 30;
        this.lookSpeed = 0.002;
        
        // Stats
        this.fps = 0;
        this.frameCount = 0;
        this.lastFpsTime = performance.now();
        this.voxelCount = 0;
        
        // Input
        this.keys = {};
        this.isLocked = false;
        
        // Light direction
        this.lightDir = this.normalize([0.5, 0.8, 0.3]);
        
        this.init();
    }
    
    normalize(v) {
        const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
        return [v[0]/len, v[1]/len, v[2]/len];
    }
    
    init() {
        const gl = this.gl;
        
        // Compile shaders
        this.program = this.createProgram(
            document.getElementById('vertex-shader').textContent,
            document.getElementById('fragment-shader').textContent
        );
        
        // Get locations
        this.locations = {
            a_position: gl.getAttribLocation(this.program, 'a_position'),
            u_voxelData: gl.getUniformLocation(this.program, 'u_voxelData'),
            u_cameraPos: gl.getUniformLocation(this.program, 'u_cameraPos'),
            u_cameraDir: gl.getUniformLocation(this.program, 'u_cameraDir'),
            u_cameraUp: gl.getUniformLocation(this.program, 'u_cameraUp'),
            u_cameraRight: gl.getUniformLocation(this.program, 'u_cameraRight'),
            u_resolution: gl.getUniformLocation(this.program, 'u_resolution'),
            u_fov: gl.getUniformLocation(this.program, 'u_fov'),
            u_worldSize: gl.getUniformLocation(this.program, 'u_worldSize'),
            u_maxSteps: gl.getUniformLocation(this.program, 'u_maxSteps'),
            u_showNormals: gl.getUniformLocation(this.program, 'u_showNormals'),
            u_enableShadows: gl.getUniformLocation(this.program, 'u_enableShadows'),
            u_lightDir: gl.getUniformLocation(this.program, 'u_lightDir'),
        };
        
        // Create full-screen quad
        const quadVerts = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
        this.quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
        
        // Create VAO
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);
        gl.enableVertexAttribArray(this.locations.a_position);
        gl.vertexAttribPointer(this.locations.a_position, 2, gl.FLOAT, false, 0, 0);
        
        // Initialize voxel world
        this.createVoxelTexture();
        this.generateScene('demo');
        
        // Setup inputs
        this.setupInputs();
        this.resize();
        
        window.addEventListener('resize', () => this.resize());
    }
    
    createShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    createProgram(vertexSource, fragmentSource) {
        const gl = this.gl;
        const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }
    
    createVoxelTexture() {
        const gl = this.gl;
        
        if (this.voxelTexture) {
            gl.deleteTexture(this.voxelTexture);
        }
        
        this.voxelTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_3D, this.voxelTexture);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
        
        // Allocate empty texture
        const size = this.worldSize;
        this.voxelData = new Uint8Array(size * size * size * 4);
        gl.texImage3D(gl.TEXTURE_3D, 0, gl.RGBA8, size, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.voxelData);
    }
    
    setVoxel(x, y, z, r, g, b) {
        const size = this.worldSize;
        if (x < 0 || x >= size || y < 0 || y >= size || z < 0 || z >= size) return;
        const idx = (x + y * size + z * size * size) * 4;
        this.voxelData[idx] = r;
        this.voxelData[idx + 1] = g;
        this.voxelData[idx + 2] = b;
        this.voxelData[idx + 3] = 255; // Alpha = occupied
    }
    
    uploadVoxelData() {
        const gl = this.gl;
        const size = this.worldSize;
        gl.bindTexture(gl.TEXTURE_3D, this.voxelTexture);
        gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, size, size, size, gl.RGBA, gl.UNSIGNED_BYTE, this.voxelData);
        
        // Count voxels
        this.voxelCount = 0;
        for (let i = 3; i < this.voxelData.length; i += 4) {
            if (this.voxelData[i] > 0) this.voxelCount++;
        }
    }
    
    generateScene(type) {
        const size = this.worldSize;
        this.voxelData.fill(0);
        
        switch (type) {
            case 'demo': this.generateDemoScene(); break;
            case 'sphere': this.generateSphereScene(); break;
            case 'terrain': this.generateTerrainScene(); break;
            case 'city': this.generateCityScene(); break;
        }
        
        this.uploadVoxelData();
        
        // Reset camera position based on world size
        this.cameraPos = [size/2, size * 0.7, -size * 0.3];
    }
    
    generateDemoScene() {
        const size = this.worldSize;
        
        // Ground plane
        for (let x = 0; x < size; x++) {
            for (let z = 0; z < size; z++) {
                const color = ((x + z) % 2 === 0) ? [58, 90, 64] : [88, 129, 87];
                this.setVoxel(x, 0, z, ...color);
            }
        }
        
        // Structures
        const structures = [
            { x: size*0.3, z: size*0.3, h: size*0.4, color: [233, 57, 70] },
            { x: size*0.6, z: size*0.45, h: size*0.55, color: [69, 123, 157] },
            { x: size*0.45, z: size*0.75, h: size*0.35, color: [244, 162, 97] },
            { x: size*0.75, z: size*0.25, h: size*0.5, color: [42, 157, 143] },
            { x: size*0.25, z: size*0.7, h: size*0.3, color: [233, 196, 106] },
        ];
        
        for (const s of structures) {
            const w = Math.max(2, Math.floor(size * 0.08));
            for (let y = 1; y <= s.h; y++) {
                for (let dx = -w; dx <= w; dx++) {
                    for (let dz = -w; dz <= w; dz++) {
                        this.setVoxel(Math.floor(s.x) + dx, y, Math.floor(s.z) + dz, ...s.color);
                    }
                }
            }
        }
        
        // Scattered voxels
        const colors = [[155, 34, 38], [174, 32, 18], [187, 62, 3], [202, 103, 2], [238, 155, 0]];
        for (let i = 0; i < size * 8; i++) {
            const x = Math.floor(Math.random() * size);
            const y = Math.floor(Math.random() * size * 0.15) + 1;
            const z = Math.floor(Math.random() * size);
            const color = colors[Math.floor(Math.random() * colors.length)];
            this.setVoxel(x, y, z, ...color);
        }
    }
    
    generateSphereScene() {
        const size = this.worldSize;
        const cx = size / 2, cy = size / 2, cz = size / 2;
        const radius = size / 2 - 2;
        const thickness = Math.max(2, size * 0.06);
        
        for (let x = 0; x < size; x++) {
            for (let y = 0; y < size; y++) {
                for (let z = 0; z < size; z++) {
                    const dx = x - cx, dy = y - cy, dz = z - cz;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist <= radius && dist >= radius - thickness) {
                        const r = Math.floor((x / size) * 127 + 128);
                        const g = Math.floor((y / size) * 127 + 128);
                        const b = Math.floor((z / size) * 127 + 128);
                        this.setVoxel(x, y, z, r, g, b);
                    }
                }
            }
        }
    }
    
    generateTerrainScene() {
        const size = this.worldSize;
        const scale = 0.15;
        
        for (let x = 0; x < size; x++) {
            for (let z = 0; z < size; z++) {
                const noise1 = Math.sin(x * scale) * Math.cos(z * scale);
                const noise2 = Math.sin(x * scale * 2 + 1) * Math.cos(z * scale * 2 + 1) * 0.5;
                const height = Math.floor(((noise1 + noise2) * 0.5 + 0.5) * size * 0.4) + 1;
                
                for (let y = 0; y < height; y++) {
                    let color;
                    if (y === height - 1) color = [74, 124, 89]; // Grass
                    else if (y > height - 4) color = [139, 94, 60]; // Dirt
                    else color = [107, 107, 107]; // Stone
                    this.setVoxel(x, y, z, ...color);
                }
            }
        }
        
        // Trees
        const numTrees = Math.floor(size * 0.4);
        for (let i = 0; i < numTrees; i++) {
            const tx = Math.floor(Math.random() * (size - 6)) + 3;
            const tz = Math.floor(Math.random() * (size - 6)) + 3;
            
            // Find ground height
            let groundY = 0;
            for (let y = size - 1; y >= 0; y--) {
                const idx = (tx + y * size + tz * size * size) * 4;
                if (this.voxelData[idx + 3] > 0) { groundY = y; break; }
            }
            
            const treeHeight = Math.floor(Math.random() * 4) + 4;
            // Trunk
            for (let y = groundY + 1; y < groundY + treeHeight + 1; y++) {
                this.setVoxel(tx, y, tz, 93, 64, 55);
            }
            // Leaves
            const leafY = groundY + treeHeight;
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = 0; dy <= 2; dy++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        if (Math.abs(dx) + Math.abs(dz) + dy <= 3) {
                            this.setVoxel(tx + dx, leafY + dy, tz + dz, 46, 125, 50);
                        }
                    }
                }
            }
        }
    }
    
    generateCityScene() {
        const size = this.worldSize;
        
        // Ground
        for (let x = 0; x < size; x++) {
            for (let z = 0; z < size; z++) {
                this.setVoxel(x, 0, z, 66, 66, 66);
            }
        }
        
        // Buildings on grid
        const gridSize = Math.max(4, Math.floor(size / 8));
        for (let gx = 1; gx < size / gridSize - 1; gx++) {
            for (let gz = 1; gz < size / gridSize - 1; gz++) {
                if (Math.random() > 0.3) {
                    const bx = gx * gridSize + 1;
                    const bz = gz * gridSize + 1;
                    const height = Math.floor(Math.random() * size * 0.5) + Math.floor(size * 0.1);
                    const width = Math.floor(Math.random() * 2) + Math.max(2, Math.floor(gridSize * 0.5));
                    
                    const colors = [[120, 144, 156], [144, 164, 174], [176, 190, 197], [96, 125, 139], [69, 90, 100]];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    for (let y = 1; y <= height; y++) {
                        for (let dx = 0; dx < width; dx++) {
                            for (let dz = 0; dz < width; dz++) {
                                const isWindow = (y % 3 === 0) && ((dx + dz) % 2 === 0);
                                const voxelColor = isWindow ? [255, 245, 157] : color;
                                this.setVoxel(bx + dx, y, bz + dz, ...voxelColor);
                            }
                        }
                    }
                }
            }
        }
    }
    
    setupInputs() {
        window.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (e.code === 'Escape' && this.isLocked) {
                document.exitPointerLock();
            }
        });
        window.addEventListener('keyup', (e) => this.keys[e.code] = false);
        
        this.canvas.addEventListener('click', () => {
            if (!this.isLocked) this.canvas.requestPointerLock();
        });
        
        document.addEventListener('pointerlockchange', () => {
            this.isLocked = document.pointerLockElement === this.canvas;
            document.getElementById('overlay').classList.toggle('hidden', this.isLocked);
            document.querySelector('.crosshair').classList.toggle('visible', this.isLocked);
            this.canvas.parentElement.classList.toggle('locked', this.isLocked);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (this.isLocked) {
                this.cameraYaw += e.movementX * this.lookSpeed;
                this.cameraPitch -= e.movementY * this.lookSpeed;
                this.cameraPitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, this.cameraPitch));
            }
        });
        
        this.canvas.addEventListener('wheel', (e) => {
            this.fov = Math.max(30, Math.min(120, this.fov + e.deltaY * 0.05));
            document.getElementById('fov').value = this.fov;
            document.getElementById('fov-val').textContent = Math.round(this.fov) + '¬∞';
        });
        
        // UI Controls
        document.getElementById('resolution').addEventListener('input', (e) => {
            this.resolutionScale = parseFloat(e.target.value);
            document.getElementById('resolution-val').textContent = this.resolutionScale + 'x';
            this.resize();
        });
        
        document.getElementById('world-size').addEventListener('change', (e) => {
            this.worldSize = parseInt(e.target.value);
            this.createVoxelTexture();
            this.generateScene(document.getElementById('scene').value);
        });
        
        document.getElementById('max-steps').addEventListener('input', (e) => {
            this.maxSteps = parseInt(e.target.value);
            document.getElementById('max-steps-val').textContent = e.target.value;
        });
        
        document.getElementById('fov').addEventListener('input', (e) => {
            this.fov = parseInt(e.target.value);
            document.getElementById('fov-val').textContent = e.target.value + '¬∞';
        });
        
        document.getElementById('scene').addEventListener('change', (e) => {
            this.generateScene(e.target.value);
        });
        
        document.getElementById('show-normals').addEventListener('change', (e) => {
            this.showNormals = e.target.checked;
        });
        
        document.getElementById('enable-shadows').addEventListener('change', (e) => {
            this.enableShadows = e.target.checked;
        });
    }
    
    resize() {
        const container = this.canvas.parentElement;
        const w = Math.floor(container.clientWidth * this.resolutionScale);
        const h = Math.floor(container.clientHeight * this.resolutionScale);
        this.canvas.width = w;
        this.canvas.height = h;
        this.gl.viewport(0, 0, w, h);
    }
    
    getCameraVectors() {
        const dir = [
            Math.cos(this.cameraPitch) * Math.sin(this.cameraYaw),
            Math.sin(this.cameraPitch),
            Math.cos(this.cameraPitch) * Math.cos(this.cameraYaw)
        ];
        const right = [Math.cos(this.cameraYaw), 0, -Math.sin(this.cameraYaw)];
        const up = [
            dir[1] * right[2] - dir[2] * right[1],
            dir[2] * right[0] - dir[0] * right[2],
            dir[0] * right[1] - dir[1] * right[0]
        ];
        return { dir, right, up };
    }
    
    update(deltaTime) {
        const speed = this.moveSpeed * deltaTime;
        const { dir, right } = this.getCameraVectors();
        
        if (this.keys['KeyW']) {
            this.cameraPos[0] += dir[0] * speed;
            this.cameraPos[1] += dir[1] * speed;
            this.cameraPos[2] += dir[2] * speed;
        }
        if (this.keys['KeyS']) {
            this.cameraPos[0] -= dir[0] * speed;
            this.cameraPos[1] -= dir[1] * speed;
            this.cameraPos[2] -= dir[2] * speed;
        }
        if (this.keys['KeyA']) {
            this.cameraPos[0] -= right[0] * speed;
            this.cameraPos[2] -= right[2] * speed;
        }
        if (this.keys['KeyD']) {
            this.cameraPos[0] += right[0] * speed;
            this.cameraPos[2] += right[2] * speed;
        }
        if (this.keys['KeyQ']) this.cameraPos[1] -= speed;
        if (this.keys['KeyE']) this.cameraPos[1] += speed;
    }
    
    render() {
        const gl = this.gl;
        const { dir, right, up } = this.getCameraVectors();
        
        gl.useProgram(this.program);
        gl.bindVertexArray(this.vao);
        
        // Set uniforms
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_3D, this.voxelTexture);
        gl.uniform1i(this.locations.u_voxelData, 0);
        
        gl.uniform3fv(this.locations.u_cameraPos, this.cameraPos);
        gl.uniform3fv(this.locations.u_cameraDir, dir);
        gl.uniform3fv(this.locations.u_cameraUp, up);
        gl.uniform3fv(this.locations.u_cameraRight, right);
        gl.uniform2f(this.locations.u_resolution, this.canvas.width, this.canvas.height);
        gl.uniform1f(this.locations.u_fov, this.fov);
        gl.uniform1f(this.locations.u_worldSize, this.worldSize);
        gl.uniform1i(this.locations.u_maxSteps, this.maxSteps);
        gl.uniform1i(this.locations.u_showNormals, this.showNormals ? 1 : 0);
        gl.uniform1i(this.locations.u_enableShadows, this.enableShadows ? 1 : 0);
        gl.uniform3fv(this.locations.u_lightDir, this.lightDir);
        
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    
    updateStats() {
        this.frameCount++;
        const now = performance.now();
        
        if (now - this.lastFpsTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastFpsTime = now;
        }
        
        const { dir } = this.getCameraVectors();
        
        document.getElementById('fps').textContent = this.fps;
        document.getElementById('frame-time').textContent = (1000 / Math.max(1, this.fps)).toFixed(1) + ' ms';
        document.getElementById('resolution-display').textContent = `${this.canvas.width} x ${this.canvas.height}`;
        document.getElementById('voxel-count').textContent = this.voxelCount.toLocaleString();
        document.getElementById('cam-pos').textContent = `(${this.cameraPos[0].toFixed(1)}, ${this.cameraPos[1].toFixed(1)}, ${this.cameraPos[2].toFixed(1)})`;
        document.getElementById('cam-dir').textContent = `(${dir[0].toFixed(2)}, ${dir[1].toFixed(2)}, ${dir[2].toFixed(2)})`;
    }
}

// ============================================================================
// Main
// ============================================================================

const canvas = document.getElementById('canvas');
const engine = new VoxelEngineWebGL2(canvas);

let lastTime = performance.now();

function gameLoop() {
    const now = performance.now();
    const deltaTime = (now - lastTime) / 1000;
    lastTime = now;
    
    engine.update(deltaTime);
    engine.render();
    engine.updateStats();
    
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
